{
  "hash": "9cc6c0ebbe31415aaf9d7e9020c2e185",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Outcome Modeling\"\nformat:\n  html:\n    toc: true\n    toc-expansion: true\n---\n\n\n::: {.cell}\n\n:::\n\n\nOutcome modeling is a general tool for estimating causal effects under selection on observables. This page introduces this idea with a focus on survival outcome modeling for time-to-event data in the presence of ignorable censoring.\n\n## From identification to outcome modeling\n\nThe identification page ended with this equation:\n\n$$\n\\begin{aligned}\n\\text{P}(Y^a > t) \n&= \\sum_{\\vec{x}} \\text{P}(Y^a>t\\mid\\vec{X} = \\vec{x})\\text{P}(\\vec{X} = \\vec{x}) &\\text{by law of total probability} \\\\\n&= \\sum_{\\vec{x}} \\text{P}(Y>t\\mid \\vec{X} = \\vec{x}, A = a)\\text{P}(\\vec{X} = \\vec{x}) &\\text{by selection on observables}\n\\end{aligned}\n$$\n\nThe equation above sums over strata $\\vec{x}$ weighted by their size. We can equivalently write the estimand as a sum over individuals in the population of size $N$,\n\n$$\n\\begin{aligned}\n\\text{P}(Y^a > t) \n&= \\frac{1}{N}\\sum_{i=1}^N \\text{P}(Y>t\\mid\\vec{X} = \\vec{x}_i, A = a) &\\text{by selection on observables}\n\\end{aligned}\n$$\n\nwhich is equivalent because each $\\vec{x}$ values is weighted by the sum of population units with that $\\vec{x}$ value.\n\n## Sample estimator in math\n\nSuppose we have a simple random sample $\\vec{S}$ where each $S_i$ indicates inclusion in the sample and the sample size is $\\sum_{i=1}^N S_i = n$. A sample estimator is the analogous sample mean,\n\n$$\n\\begin{aligned}\n\\hat{\\text{P}}_{\\vec{S}}(Y^a > t) \n&= \\frac{1}{n}\\sum_{i:S_i=1} \\hat{\\text{P}}_{\\vec{S}}(Y>t\\mid\\vec{X} = \\vec{x}_i, A = a) &\\text{by selection on observables}\n\\end{aligned}\n$$\n\nwhere $\\hat{\\text{P}}_{\\vec{S}}$ refers to the probability estimated in sample $\\vec{S}$. This points to an estimation strategy:\n\n1. **Model:** Learn a survival model for $Y > t$ given $\\vec{X}$ and $A$\n2. **Modify data:** Set $A_i = a$ for all $i$\n3. **Predict.** For each $i$, predict the counterfactual survival probability.\n4. **Average.** Take the average across all people.\n\nTo estimate causal effects, repeat steps (1--4) for each treatment value $a$ and difference over treatment values.\n\n## Worked example in code\n\nThe `veteran` data in the `survival` package contains a randomized controlled trial in which lung cancer patients were randomly assigned to a standard or experimental medical treatment (`trt` = 1 for standard, `trt` = 2 for experimental). The outcome variable is `time` and death is indicated by `status` = 1 vs censored with `status = 0`. Pre-treatment covariates are\n\n* `karno`: Karnofsky performance score (100=good)\n* `diagtime`: Months from diagnosis to randomization\n* `age`: In years\n* `prior`: Whether the patient had prior therapy\n\nImagine that these data were not from a randomized trial, but rather an observational study. Assume ignorable censoring and that selection on observables holds with these confounders. Write code to estimate the causal effect of treatment on survival at time $t = 52$ weeks.\n\nTry sketching it out for yourself before looking at the code below.\n\nStep 1. **Model:** Learn a survival model for $Y > t$ given $\\vec{X}$ and $A$\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmodel <- survreg(\n  Surv(time, status) ~ trt * (karno + diagtime + age + prior),\n  data = veteran,\n  dist = \"weibull\"\n)\n```\n:::\n\n\nStep 2. **Modify data:** Set $A_i = a$ for all $i$\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nunder_treatment <- veteran |> mutate(trt = 2)\nunder_control <- veteran |> mutate(trt = 1)\n```\n:::\n\n\nStep 3. **Predict.** For each $i$, predict the counterfactual survival probability.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsurvival_probability <- function(model, newdata, time_point) {\n  # Check that `time_point` is not a column of `newdata`\n  if (any(colnames(newdata) == \"time_point\")) {\n    stop(\"Error: Function will not work if time_point is both an argument and a column of newdata. To use this function, revise model and newdata so they do not involve a variable named time_point.\")\n  }\n  newdata |>\n    mutate(\n    shape = 1 / model$scale,\n    xb = predict(model, type = \"linear\", newdata = newdata),\n    survival_prob = pweibull(\n      q = time_point,\n      shape = shape,\n      scale = exp(xb),\n      lower.tail = FALSE\n    )\n  )\n}\n\ns_under_treatment <- model |>\n  survival_probability(newdata = under_treatment, time_point = 52) |>\n  head()\n\ns_under_control <- model |>\n  survival_probability(newdata = under_control, time_point = 52)\n```\n:::\n\n\nStep 4. **Average.** Take the average across all people.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ns_under_treatment |> select(survival_prob) |> summarize_all(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  survival_prob\n1     0.5895287\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\ns_under_control |> select(survival_prob) |> summarize_all(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  survival_prob\n1     0.6237029\n```\n\n\n:::\n:::\n\n\n",
    "supporting": [
      "outcome_model_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}